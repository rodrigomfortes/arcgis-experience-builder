/*! For license information please see arcgis_analysis_node_modules_arcgis_map-config-components_dist_esm-98d541.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_map-config-components_dist_esm-98d541"],{10465:(e,t,n)=>{n.d(t,{D:()=>a,a:()=>c,b:()=>l,c:()=>o,g:()=>g,s:()=>y});class a{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}const r=(e,t,n)=>(0,s(t).subscribe)((t=>{const a=t.some((t=>((e,t)=>{let n=e;for(;n;){if(n===t)return!0;if(!n.parentNode)return!1;n=n.parentNode instanceof ShadowRoot?n.parentNode.host:n.parentNode}return!1})(e,t.target)));a&&n()})),i={},s=e=>{const t=e.join(","),n=i[t];if(void 0!==n)return n;const a=new Set,r=new MutationObserver((e=>a.forEach((t=>t(e)))));globalThis.document&&r.observe(document.documentElement,{attributes:!0,attributeFilter:e,subtree:!0});const s={subscribe:e=>(a.add(e),()=>{a.delete(e),0===a.size&&(r.disconnect(),i[t]=void 0)})};return i[t]=s,s},o=(e,t)=>{let n=e;for(;n;){const e=n.closest?.(t);if(e)return e;const a=n.getRootNode?.();if(a===globalThis.document)return null;n=a.host}return null},l=e=>u(e,"dir","ltr"),u=(e,t,n)=>{const a=o(e,`[${t}]`);return a?.getAttribute(t)??n},d=e=>{let t="";for(let n=0;n<e;n++)t+=(65536*(1+Math.random())|0).toString(16).substring(1);return t},c=()=>[d(2),d(1),d(1),d(1),d(3)].join("-"),f="ar,bg,bs,ca,cs,da,de,el,en,es,et,fi,fr,he,hr,hu,id,it,ja,ko,lt,lv,nl,nb,no,pl,pt-BR,pt-PT,ro,ru,sk,sl,sr,sv,th,tr,uk,vi,zh-CN,zh-HK,zh-TW".split(","),p=new Set(f),h="en",m={pt:"pt-PT",nb:"no",nn:"no",zh:"zh-CN"},T={},E=async(e,t)=>{const n=`${t}${e}.json`;try{const e=await fetch(n);if(e.ok)return await e.json()}catch(e){return console.error(e),{}}return e===h?{}:await E(h,t)},g=e=>{const t=u(e,"lang",globalThis.navigator?.language||h);return{lang:t,t9nLocale:P(t)}},P=e=>{const[t,n]=e.split("-"),a=t.toLowerCase();let r=a;return n&&(r=`${a}-${n.toUpperCase()}`),r=m[r]??r,p.has(r)?r:n?P(a):h},y=(e,t,n,a)=>{let i;const s=()=>v(e,t(),a).then((e=>{i?.lang===e.lang&&i.t9nLocale===e.t9nLocale&&i.t9nStrings===e.t9nStrings||n(e),i=e})).catch(console.error);return queueMicrotask(s),r(e,["lang"],s)},v=async(e,t,n=e.localName.split("-").slice(1).join("-"))=>{const{lang:a,t9nLocale:r}=g(e),i=`${t}/${n}/t9n`,s=null===n?{}:await(async(e,t,n="")=>{const a=`${t}/${n}`,r=`${a}${e}.json`;return T[r]??(T[r]=E(e,a)),await T[r]})(r,i,"messages.");return{lang:a,t9nLocale:r,t9nStrings:s}}},20057:(e,t,n)=>{function a(e){return`// To configure a time series visualization using this template, data for this layer should be structured so that\n// each row represents a static feature with a fixed location, such as a country boundary or a city location.\n// The attribute table should have two or more fields that represent the same data attributes at different points in time for each feature.\n// Field names should refer to a specific attribute and a specific point in time, such as population in a specific year.\n// e.g. POP1990, POP2000, POP2010, POP2020, POP2030\n\n// There are four areas of this template where modification is necessary for the template to work with your layer\n// Two are required, and two are optional. \n\n// Examine your data and the details below to edit the template accordingly.\n\nvar FIELD_NAME_PATTERN = "POP{Y}"; // Required - Update this to match your data. See Lines 17-49 for details.\nExpects($feature, "POP*"); // Required - Update this to match your data. See Lines 51-63 for details.\nvar DEFAULT_FIELD_NAME = ""; // Optional - See Lines 65-79 for details.\nvar RESULT_FORMAT_PATTERN = "${e?.resultFormatPattern??"#,###.00"}"; // Optional - Update this to match your data. See Lines 81-93 for details.\n\n// FIELD_NAME_PATTERN\n//\n// The field name pattern is used to create the field name from the time slider values.\n// Patterns are defined using the following syntax: fieldName{pattern}\n//\n// EXAMPLE 1: given fields with names Cases_2023_10_01, Cases_2023_10_02, Cases_2023_10_03, etc., the field name pattern would be:\n// var FIELD_NAME_PATTERN = "Cases_{Y_MM_DD}";\n//\n// EXAMPLE 2: given fields with names POP2000, POP2010, POP2020, etc., the field name pattern would be:\n// var FIELD_NAME_PATTERN = "POP{Y}";\n//\n// The following patterns are supported:\n//\n// D: Day of the month, not padded (1 - 31)\n// DD: Day of the month, padded (01 - 31)\n// DDD: Ordinal day of the year (1 - 365)\n// d: Day of the week (1 - 7)\n// ddd: Abbreviated day of the week (e.g. Mon)\n// dddd: Full day of the week (e.g. Monday)\n// M: Month number (1 - 12)\n// MM: Month number, padded (01 - 12)\n// MMM: Abbreviated month name (e.g. Jan)\n// MMMM: Full month name (e.g. January)\n// Y: Full year\n// YY: Two-digit year\n// h: Civilian hours, not padded (1 - 12)\n// hh: Civilian hours, padded (01 - 12)\n// H: Military hours, not padded (0 - 23)\n// HH: Military hours, padded (00 - 23)\n// m: Minutes, not padded (0 - 59)\n// mm: Minutes, padded (00 - 59)\n// s: Seconds, not padded (0 - 59)\n// ss: Seconds, padded (00 - 59)\n\n// EXPECTS\n//\n// Copy and paste the part of the field pattern common to all fields\n// followed by an asterisk (*) into the second parameter of the Expects function.\n// This must be a raw text value like "POP*", not a variable name like FIELD_NAME_PATTERN.\n// \n// EXAMPLE 1: given fields with names Cases_2023_10_01, Cases_2023_10_02, Cases_2023_10_03, etc.\n//   - Expects($feature, \u201cCases_*\u201d);  // includes all fields that start with "Cases_"\n//   - Expects($feature, \u201cCases_2023*\u201d); // includes all Cases fields for the year 2023\n// \n// EXAMPLE 2: given fields with names POP2000, POP2010, POP2020, etc.\n//   - Expects($feature, "POP*"); // includes all fields that start with "POP"\n//   - Expects($feature, "POP2*"); // includes all "POP" fields for all years after 2000\n\n// DEFAULT_FIELD_NAME\n//\n// The field name to return if the time slider is closed.\n// Suggested values might include the first field in the time series,\n// the most recent field in the time series, or possibly an\n// aggregated value, such as TOTAL_POPULATION.\n// \n// EXAMPLE 1: The first field in the time series. Given fields with names POP2000, POP2010, POP2020, TOTAL_POPULATION,\n// var DEFAULT_FIELD_NAME = "POP2000";\n//\n// EXAMPLE 2: An aggregated value such as the total population. Given fields with names POP2000, POP2010, POP2020, TOTAL_POPULATION,\n// var DEFAULT_FIELD_NAME = "TOTAL_POPULATION";\n//\n// Note - If you defined a default field, be sure to include it in the Expects function as a third parameter.\n// e.g. Expects($feature, "POP*", "TOTAL_POPULATION");\n\n// RESULT_FORMAT_PATTERN\n//\n// The result format pattern is used to format the result of the calculation.\n// Patterns are defined using the following syntax: #,###.00\n// This should only be defined for formatting numeric values in labels or popups.\n// If using for symbology/layer styles, or the field data type\n// is a string, then leave this value empty.\n//\n// EXAMPLE 1: if returning a numeric value in a label,\n// var RESULT_FORMAT_PATTERN = "#,###"; // formats the value with commas and rounded to nearest integer\n// \n// EXAMPLE 2: if returning a numeric value in a popup,\n// var RESULT_FORMAT_PATTERN = "#,###.00"; // formats the value with commas and two decimal places\n\nfunction fieldsWithPatternFilter(field) {\n  var prefix = Front(Split(FIELD_NAME_PATTERN, "{"));\n  var suffix = Back(Split(FIELD_NAME_PATTERN, "}"));\n  var patternToFind = DefaultValue(prefix, suffix);\n  return Find(patternToFind, field.name) > -1;\n}\n\nfunction fieldsWithPatternMap(field) {\n  return field.name;\n}\n\nfunction getAllFieldsFromPattern() {\n  var fields = Schema($feature).fields;\n  return Sort(\n    Map(Filter(fields, fieldsWithPatternFilter), fieldsWithPatternMap)\n  );\n}\n\nfunction getFieldNameFromTimeProperties(dateValue, pattern) {\n  var fieldName = pattern;\n\n  var startPosition = Find("{", fieldName);\n  while (startPosition > -1) {\n    var startIndex = Find("{", fieldName, startPosition);\n    var endIndex = Find("}", fieldName, startIndex);\n    var searchText = Mid(fieldName, startIndex, endIndex - startIndex + 1);\n    var dateText = Text(dateValue, searchText);\n    fieldName = Replace(fieldName, searchText, dateText);\n    startPosition = Find("{", fieldName, endIndex);\n  }\n  fieldName = Replace(Replace(fieldName, "{", ""), "}", "");\n  return fieldName;\n}\n\nvar hasCurrentStart = HasValue($view, ["timeProperties", "currentStart"]);\nvar hasCurrentEnd = HasValue($view, ["timeProperties", "currentEnd"]);\n\nvar hasTimeProperties = hasCurrentStart || hasCurrentEnd;\n\nif (!hasTimeProperties) {\n  if (!IsEmpty(DEFAULT_FIELD_NAME) && HasKey($feature, DEFAULT_FIELD_NAME)) {\n    return $feature[DEFAULT_FIELD_NAME];\n  }\n  var firstField = Front(getAllFieldsFromPattern());\n  return $feature[firstField];\n}\n\nvar currentValue = DefaultValue(\n  $view.timeProperties.currentEnd,\n  $view.timeProperties.currentStart\n);\n\nfunction getValueAtInstant() {\n  var fieldName = getFieldNameFromTimeProperties(\n    currentValue,\n    FIELD_NAME_PATTERN\n  );\n  if (HasValue($feature, fieldName)) {\n    var value = $feature[fieldName];\n    return value;\n  }\n  return null;\n}\n\nfunction formatResult(value) {\n  if (IsEmpty(value)) {\n    return null;\n  }\n  if (IsEmpty(RESULT_FORMAT_PATTERN)) {\n    return value;\n  }\n  return Text(value, RESULT_FORMAT_PATTERN);\n}\n\nvar result = getValueAtInstant();\nreturn formatResult(result);`}n.d(t,{g:()=>a})},51523:(e,t,n)=>{n.d(t,{g:()=>s});var a=n(69811),r=n(56612),i=n(17840);async function s(e,t){return await async function(e,t){const n=await(0,a.f)(),s=[],o=new Map(t?.fieldInfos?.map((e=>[e.fieldName,e]))),l=await(0,i.f)(e);return l?.size&&(o.forEach((e=>{l.has(e.fieldName)&&("geometry"!==l.get(e.fieldName).type&&s.push(e),l.delete(e.fieldName))})),l.forEach((e=>{if(!["geometry"].includes(e.type)){const t=new n;t.fieldName=e.name,t.label=e.alias,t.visible=!1,s.push(t)}})),l.clear()),t?.expressionInfos&&t.expressionInfos?.forEach((e=>{const t=`${r.f.expression}${e.name}`;if(o.has(t))s.push(o.get(t));else{const e=new n;e.fieldName=t,e.visible=!1,s.push(e)}})),t?.fieldInfos?.forEach((e=>{e.fieldName.includes(r.f.relationship)&&s.push(e)})),await Promise.resolve(s)}(e,t)}},53287:(e,t,n)=>{n.d(t,{a:()=>o,b:()=>l,c:()=>u,d:()=>h,e:()=>d,f:()=>p,g:()=>c,s:()=>f});var a=n(56612),r=n(17840),i=n(51523),s=n(20057);async function o(e,t,n,i,s){return s===a.l.cluster?{id:"popup-feature-reduction",definitions:{$feature:{fields:(0,r.j)(i,!1)},$aggregatedFeatures:await m(t,e,i)}}:n===a.s.voxel?{id:"popup-voxel",definitions:{$voxel:e}}:{id:"popup",...(n===a.s.mapImage||n===a.s.scene||n===a.s.tile)&&{disabledVariables:["$layer","$map","$datastore"]},...(n===a.s.geojson||n===a.s.wfs||n===a.s.csv)&&{disabledVariables:["$datastore"]},definitions:{$feature:e,$layer:e,$map:t.map,$datastore:e}}}async function l(e,t,n,i){try{if("subtype-sublayer"!==e.type&&"voxel"!==e.type&&n===a.l.cluster)return{profileVariableInstances:{$feature:await(0,r.k)(t,e,i),$aggregatedFeatures:await m(t,e,i),$view:{scale:"scale"in t?t.scale:void 0,timeProperties:t.timeExtent?{currentStart:t.timeExtent.start,currentEnd:t.timeExtent.end,startIncluded:!0,endIncluded:!0}:void 0}},spatialReference:t.spatialReference,timeZone:t.timeZone};if("voxel"===e.type)return;return{profileVariableInstances:{$feature:(await(0,r.l)(e,t)).features[0],$layer:e,$map:t.map,$view:{scale:"scale"in t?t.scale:void 0,timeProperties:t.timeExtent?{currentStart:t.timeExtent.start,currentEnd:t.timeExtent.end,startIncluded:!0,endIncluded:!0}:void 0},$datastore:"subtype-sublayer"===e.type?e.parent.url:e.url,$userInput:t.extent?.center},spatialReference:t.spatialReference,timeZone:t.timeZone}}catch(e){console.log(e)}}function u(e,t,n){return e||(t===a.l.cluster?function(e){return`// ${e.clusterArcadeScriptLine3} \nExpects($aggregatedFeatures, "field1", "field2")\n`}(n):"")}function d(e,t,n){let a;return"popupElement"===n&&(a=[{label:t.chartTemplate,code:g()},{label:t.fieldsListTemplate,code:E()},{label:t.richText,code:T()}]),document.URL.includes("/mapviewer/")&&"attributeExpression"===n&&(a=a||[],a.push({label:t.timeSeries,description:t.timeSeriesDescription,code:(0,s.g)()})),"hasM"in e&&e.hasM&&(a=a||[],a.push({label:t.mValueTemplate,code:P()})),a?.length?[{label:t.templates,suggestions:a}]:void 0}function c(e,t){const n=`// ${t.arcadeContentClusterScriptLine} \nExpects($aggregatedFeatures, "field1", "field2")\n\n`,r=`/* \n${t.arcadeContentScriptLine1} \n${t.arcadeContentScriptLine2} \nhttps://developers.arcgis.com/arcade/guide/profiles/#popup-element \n*/\n\n${T()}`;return e===a.l.cluster?n+r:r}function f(e,t,n,a){const r=t,i=new n;return i.expression=e.script,i.title=e.title,i.name=v(a,r),i.returnType="number"===e.predictOutputType?"number":"string",a.expressionInfos?r?a.expressionInfos.find(((e,t)=>{e.name===r&&(a.expressionInfos[t]=i)})):a.expressionInfos.push(i):a.expressionInfos=[i],i}async function p(e,t){const{popupTemplate:n,layerDisplayType:r,layer:s}=e;r===a.l.cluster?(s.featureReduction.popupTemplate.expressionInfos=[...n.expressionInfos],n.fieldInfos=y(n,t)):(s.popupTemplate.expressionInfos=[...n.expressionInfos],n.fieldInfos=[...await(0,i.g)(s,n)])}function h(e){const{layer:t,mapView:n,layerDisplayType:r}=e;if(r!==a.l.cluster)return!1;return t.featureReduction.maxScale>=n.scale}async function m(e,t,n){const a=await e.whenLayerView(t),i=a.createQuery();return i.aggregateIds=[(await(0,r.k)(e,t,n)).getObjectId()],await a.queryFeatures(i)}const T=()=>"return { \n\ttype : 'text', \n\ttext : 'place your text or html here' //this property supports html tags \n}",E=()=>"return {\n    type: 'fields',\n    //title: '',\n    //description : '',\n    fieldInfos:  [{\n          fieldName: \"att1\"  // fieldName should match the key in the attributes dictionary\n        },\n        {\n          fieldName: \"att2\"  // fieldName should match the key in the attributes dictionary\n        },\n        {\n          fieldName: \"att3\"  // fieldName should match the key in the attributes dictionary\n        }],\n    attributes : {att1 : 2, att2 : 3, att3 : 4}  // replace this dictionary with your own key-value pairs\n  }",g=()=>"return {\n    type: 'media',\n    // title : 'The title for all media in the element',\n    // description : '',\n    attributes : {att1 : 2, att2 : 3, att3 : 4},  // replace this dictionary with your own key-value pairs,\n    mediaInfos: [{\n        type : 'piechart', //linechart | barchart | piechart | columnchart\n        title : 'give your chart a title',\n        // caption : '',\n        altText : '', //altText will be read by screen readers\n        value : {\n          fields: [\"att1\", \"att2\", \"att3\"],  // choose what attributes to use in the chart\n          /* colors: [  // values must be an array of [r, g, b, a] values (0-255)\n            [122, 190, 229, 255],\n            [179, 155, 213, 255],\n            [248, 174, 131, 255]\n          ], */\n          //normalizeField : '',  // the name of the attribute to normalize by or value\n        }\n      }]\n  }",P=()=>"if (TypeOf($userInput) == \"Point\") {\n  var result = PointToCoordinate($feature, $userInput);\n  return Text(result.coordinate.m, '#,###.00');\n}",y=(e,t)=>{const n=[];return e.fieldInfos.forEach((e=>{e.fieldName.includes(a.f.expression)||n.push(e)})),e.expressionInfos?.forEach((async e=>{const r=new t;r.fieldName=`${a.f.expression}${e.name}`,r.visible=!1,n.push(r)})),n},v=(e,t)=>{if(t)return t;if(e.expressionInfos?.length){const t=e.expressionInfos[e.expressionInfos.length-1].name.match(/\d+$/u);return t?.[0]?`expr${Number(t[0])+1}`:`expr${e.expressionInfos.length}`}return"expr0"}},82780:(e,t,n)=>{var a,r,i,s;n.d(t,{A:()=>r,C:()=>a,I:()=>s,P:()=>i}),function(e){e.ATTRIBUTES="attributes",e.ATTACHMENTS="attachments",e.CHARTS="charts",e.IMAGES="images",e.RICH_TEXT="richText",e.ARCADE="arcade",e.RELATIONSHIP="relationship",e.ASSOCIATIONS="associations",e.EDIT_INFO_SUMMARY="editInfoSummary"}(a||(a={})),function(e){e.PREVIEW="preview",e.LIST="list",e.AUTO="auto"}(r||(r={})),function(e){e.IMAGE="image",e.BAR_CHART="bar-chart",e.COLUMN_CHART="column-chart",e.LINE_CHART="line-chart",e.PIE_CHART="pie-chart"}(i||(i={})),function(e){e.SOURCE_URL="sourceUrl",e.TITLE="title",e.CAPTION="caption",e.LINK_URL="linkUrl",e.ALT_TEXT="altText"}(s||(s={}))},84260:(e,t,n)=>{n.d(t,{u:()=>s});var a=n(11254),r=n(10465),i=n(14528);function s({propertyName:e="strings",name:t}){let n=(0,i.r)();const s=(0,r.g)(n.el),l=new r.D,u={_lang:s.lang,_t9nLocale:s.t9nLocale};n.manager.onLoad((()=>l.promise));const d=new WeakRef(n);function c(){const e=d.deref();return e||p?.(),e}n=void 0;const f=o((()=>c()?.el)),p=(0,r.s)(f,(()=>(0,a.g)("./assets")),(({t9nLocale:t,t9nStrings:n,lang:a})=>{const r=c();if(!r)return;r[e]={...n,_lang:a,_t9nLocale:t},l.resolve()}),t);return u}const o=e=>new Proxy({},{get(t,n){const a=e();if(!a)return;const r=Reflect.get(a,n,a);return"function"==typeof r?r.bind(a):r}})}}]);